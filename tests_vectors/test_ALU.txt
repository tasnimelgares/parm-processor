# Unitary testing: test vectors for ALU

# Déclaration des signaux :

A[32] B[32] Shift[5] CarryIn[1] Codop[4] S[32] Flags[4]

# tests

# inputs outputs 
# A(32) B(32) shift(5) CI(1) codop(4) S(32) Z(1)N(1)V(1)C(1)

# ------------------------------------------------------------
# AND (codop = 0000) Drapeaux modifiés: N Z C=0
# ------------------------------------------------------------

# A = 0xFFFFFFFF, B = 0xFFFFFFFF → S = 0xFFFFFFFF, N=1, Z=0
11111111111111111111111111111111 11111111111111111111111111111111 00000 0 0000 11111111111111111111111111111111 1000

# A = 0xAAAAAAAA, B = 0x55555555 → S = 0x00000000, N=0, Z=1
10101010101010101010101010101010 01010101010101010101010101010101 00000 0 0000 00000000000000000000000000000000 0100

# A = 0xFFFFFFFF, B = 0x0F0F0F0F → S = 0x0F0F0F0F, N=0, Z=0
11111111111111111111111111111111 00001111000011110000111100001111 00000 0 0000 00001111000011110000111100001111 0000


# ------------------------------------------------------------
# EOR (codop = 0001) Drapeaux modifiés: N Z C=0
# ------------------------------------------------------------

# A = 0xFFFFFFFF, B = 0xFFFFFFFF → S = 0x00000000, N=0, Z=1
11111111111111111111111111111111 11111111111111111111111111111111 00000 0 0001 00000000000000000000000000000000 0100

# A = 0xAAAAAAAA, B = 0x55555555 → S = 0xFFFFFFFF, N=1, Z=0
10101010101010101010101010101010 01010101010101010101010101010101 00000 0 0001 11111111111111111111111111111111 1000

# A = 0xF0F0F0F0, B = 0xF0F0F0F0 → S = 0x00000000, N=0, Z=1
11110000111100001111000011110000 11110000111100001111000011110000 00000 0 0001 00000000000000000000000000000000 0100

# ------------------------------------------------------------
# LSL (codop = 0010) Drapeaux modifiés: N Z C
# ------------------------------------------------------------

# B = 0x00000001, shift = 1 → S = 0x00000002, N=0, Z=0, C=0
# Décalage minimal 1 bit, résultat positif, pas de carry
00000000000000000000000000000000 00000000000000000000000000000001 00001 0 0010 00000000000000000000000000000010 0000

# B = 0x40000000, shift = 1 → S = 0x80000000, N=1, Z=0, C=0
# Passage du bit de signe à 1
00000000000000000000000000000000 01000000000000000000000000000000 00001 0 0010 10000000000000000000000000000000 1000

# B = 0xFFFFFFFF, shift = 4 → S = 0xFFFFFFF0, N=1, Z=0, C=1
# Décalage multiple, dernier bit sortant = 1 → carry actif
00000000000000000000000000000000 11111111111111111111111111111111 00100 0 0010 11111111111111111111111111110000 1010

# B = 0x00000001, shift = 31 → S = 0x80000000, N=1, Z=0, C=0
# Décalage maximal
00000000000000000000000000000000 00000000000000000000000000000001 11111 0 0010 10000000000000000000000000000000 1000

# B = 0x00000000, shift = 5 → S = 0x00000000, N=0, Z=1, C=0
# Décalage d’une valeur nulle
00000000000000000000000000000000 00000000000000000000000000000000 00101 0 0010 00000000000000000000000000000000 0100

# B = 0x80000000, shift = 1 → S = 0x00000000, N=0, Z=1, C=1
# MSB sortant = 1 → carry actif, résultat nul
00000000000000000000000000000000 10000000000000000000000000000000 00001 0 0010 00000000000000000000000000000000 0110

# ------------------------------------------------------------
# LSR (codop = 0011) Drapeaux modifiés: N Z C
# ------------------------------------------------------------

# B = 0x00000010, shift = 1 → S = 0x00000008, N=0, Z=0, C=0
# Décalage minimal 1 bit, résultat positif, pas de carry
00000000000000000000000000000000 00000000000000000000000000010000 00001 0 0011 00000000000000000000000000001000 0000

# B = 0x80000000, shift = 1 → S = 0x40000000, N=0, Z=0, C=0
# Décalage touche le MSB, résultat positif, pas de carry
00000000000000000000000000000000 10000000000000000000000000000000 00001 0 0011 01000000000000000000000000000000 0000

# B = 0xFFFFFFFF, shift = 4 → S = 0x0FFFFFFF, N=0, Z=0, C=1
# Décalage multiple, dernier bit sortant = 1 → carry actif
00000000000000000000000000000000 11111111111111111111111111111111 00100 0 0011 00001111111111111111111111111111 0010

# B = 0x80000000, shift = 31 → S = 0x00000001, N=0, Z=0, C=0
# Décalage maximal, bit 31 devient LSB
00000000000000000000000000000000 10000000000000000000000000000000 11111 0 0011 00000000000000000000000000000001 0000

# B = 0x00000000, shift = 5 → S = 0x00000000, N=0, Z=1, C=0
# Décalage d’une valeur nulle → reste nul, flag Z actif
00000000000000000000000000000000 00000000000000000000000000000000 00101 0 0011 00000000000000000000000000000000 0100

# B = 0x00000001, shift = 1 → S = 0x00000000, N=0, Z=1, C=1
# Décalage d’une valeur avec LSB=1 → bit sortant = 1 (C=1), résultat nul → Z=1
00000000000000000000000000000000 00000000000000000000000000000001 00001 0 0011 00000000000000000000000000000000 0110

# ------------------------------------------------------------
# ASR (codop = 0100) Drapeaux modifiés: N Z C
# ------------------------------------------------------------

# B = 0x00000010, shift = 1 → S = 0x00000008, N=0, Z=0, C=0
# Décalage minimal 1 bit, bit signe 0 réinséré, pas de carry
00000000000000000000000000000000 00000000000000000000000000010000 00001 0 0100 00000000000000000000000000001000 0000

# B = 0x80000000, shift = 1 → S = 0xC0000000, N=1, Z=0, C=1
# Décalage minimal, bit signe 1 réinséré à gauche, LSB sortant = 0 → C=0
00000000000000000000000000000000 10000000000000000000000000000000 00001 0 0100 11000000000000000000000000000000 1000

# B = 0xFFFFFFFF, shift = 4 → S = 0xFFFFFFFF, N=1, Z=0, C=1
# Décalage multiple, tout rempli par le bit signe 1, dernier bit sortant = 1 → C=1
00000000000000000000000000000000 11111111111111111111111111111111 00100 0 0100 11111111111111111111111111111111 1010

# B = 0x80000000, shift = 31 → S = 0xFFFFFFFF, N=1, Z=0, C=0
# Décalage maximal, bit de signe répété, dernier bit sortant = 0 → C=0
00000000000000000000000000000000 10000000000000000000000000000000 11111 0 0100 11111111111111111111111111111111 1000

# B = 0x00000000, shift = 5 → S = 0x00000000, N=0, Z=1, C=0
# Décalage d’une valeur nulle → reste nul, flag Z actif
00000000000000000000000000000000 00000000000000000000000000000000 00101 0 0100 00000000000000000000000000000000 0100

# B = 0x00000001, shift = 1 → S = 0x00000000, N=0, Z=1, C=1
# Décalage d’une valeur positive petite, LSB sortant = 1 → C=1
00000000000000000000000000000000 00000000000000000000000000000001 00001 0 0100 00000000000000000000000000000000 0110

# ------------------------------------------------------------
# ADC (codop = 0101) Drapeaux modifiés: N Z C V
# ------------------------------------------------------------

# A = 0x00000001, B = 0x00000001, CarryIn = 0 → S = 0x00000002, N=0, Z=0, C=0, V=0
# Addition simple, résultat positif, pas de dépassement
00000000000000000000000000000001 00000000000000000000000000000001 00000 0 0101 00000000000000000000000000000010 0000

# A = 0x7FFFFFFF, B = 0x00000001, CarryIn = 0 → S = 0x80000000, N=1, Z=0, C=0, V=1
# Dépassement signé (overflow), bit de signe change
01111111111111111111111111111111 00000000000000000000000000000001 00000 0 0101 10000000000000000000000000000000 1001

# A = 0x80000000, B = 0xFFFFFFFF, CarryIn = 0 → S = 0x7FFFFFFF, N=0, Z=0, C=0, V=1
# Dépassement non signé et signé négatif → positif, overflow
10000000000000000000000000000000 11111111111111111111111111111111 00000 0 0101 01111111111111111111111111111111 0011

# A = 0x00000000, B = 0x00000000, CarryIn = 0 → S = 0x00000000, N=0, Z=1, C=0, V=0
# Résultat zéro → Z actif
00000000000000000000000000000000 00000000000000000000000000000000 00000 0 0101 00000000000000000000000000000000 0100

# A = 0xFFFFFFFF, B = 0x00000001, CarryIn = 0 → S = 0x00000000, N=0, Z=1, C=0, V=0
# Résultat zéro, dépassement signé, overflow signé négatif + positif → V=1
11111111111111111111111111111111 00000000000000000000000000000001 00000 0 0101 00000000000000000000000000000000 0110

# A = 0x80000000, B = 0x80000000, CarryIn = 0 → S = 0x00000000, N=0, Z=1, C=0, V=1
# Addition deux négatifs → résultat positif, overflow signé et non signé
10000000000000000000000000000000 10000000000000000000000000000000 00000 0 0101 00000000000000000000000000000000 0111


# A = 0x00000001, B = 0x00000001 → S = 0x00000003, N=0, Z=0, C=0, V=0
# Addition positive simple + carryin
00000000000000000000000000000001 00000000000000000000000000000001 00000 1 0101 00000000000000000000000000000011 0000

# A = 0x7FFFFFFF, B = 0x00000001 → S = 0x80000001, N=1, Z=0, C=0, V=1
# Addition positive proche du max + carryin → overflow signé
01111111111111111111111111111111 00000000000000000000000000000001 00000 1 0101 10000000000000000000000000000001 1001

# A = 0x7FFFFFFF, B = 0x7FFFFFFF → S = 0xFFFFFFFE, N=1, Z=0, C=0, V=1
# Deux grands positifs + carryin → résultat négatif → overflow
01111111111111111111111111111111 01111111111111111111111111111111 00000 1 0101 11111111111111111111111111111111 1001

# A = 0x80000000, B = 0xFFFFFFFF → S = 0x80000000, N=1, Z=0, C=0, V=0
# Négatif + petit négatif + carryin → résultat négatif, pas de overflow signé mais overflow non signé
10000000000000000000000000000000 11111111111111111111111111111111 00000 1 0101 10000000000000000000000000000000 1010

# A = 0x80000000, B = 0x80000000 → S = 0x00000001, N=0, Z=0, C=0, V=1
# Deux négatifs + carryin → résultat positif → overflow signé et non signé
10000000000000000000000000000000 10000000000000000000000000000000 00000 1 0101 00000000000000000000000000000001 0011

# A = 0x00000000, B = 0x00000000 → S = 0x00000001, N=0, Z=0, C=0, V=0
# Zéro + zéro + carryin → résultat 1
00000000000000000000000000000000 00000000000000000000000000000000 00000 1 0101 00000000000000000000000000000001 0000

# ------------------------------------------------------------
# SBC (codop = 0110) : B - A + (C_in - 1), flags N Z C V
# ------------------------------------------------------------

# A = 0x00000001, B = 0x00000001, CarryIn=0 → S = -1
# N=1, Z=0, C=0, V=0
00000000000000000000000000000001 00000000000000000000000000000001 00000 0 0110 11111111111111111111111111111111 1000

# A = 0x00000001, B = 0x80000000, CarryIn=0 → S = 0x7FFFFFFE, overflow signé
# N=0, Z=0, C=1, V=1
00000000000000000000000000000001 10000000000000000000000000000000 00000 0 0110 01111111111111111111111111111110 0011

# A = 0xFFFFFFFF, B = 0xFFFFFFFF, CarryIn=0 → S = -1
# N=1, Z=0, C=0, V=0
11111111111111111111111111111111 11111111111111111111111111111111 00000 0 0110 11111111111111111111111111111111 1000

# A = 0x00000000, B = 0x00000000, CarryIn=0 → S = -1
# N=1, Z=0, C=0, V=0
00000000000000000000000000000000 00000000000000000000000000000000 00000 0 0110 11111111111111111111111111111111 1000

# A = 0xFFFFFFFF, B = 0x00000001, CarryIn=0 → S = 0x00000001
# N=0, Z=0, C=0, V=0
11111111111111111111111111111111 00000000000000000000000000000001 00000 0 0110 00000000000000000000000000000001 0000

# A = 0x00000001, B = 0x00000001, CarryIn=1 → S = 0
# N=0, Z=1, C=1, V=0
00000000000000000000000000000001 00000000000000000000000000000001 00000 1 0110 00000000000000000000000000000000 0110

# A = 0x00000001, B = 0x80000000, CarryIn=1 → S = 0x7FFFFFFF, overflow signé
# N=0, Z=0, C=1, V=1
00000000000000000000000000000001 10000000000000000000000000000000 00000 1 0110 01111111111111111111111111111111 0011

# A = 0xFFFFFFFF, B = 0xFFFFFFFF, CarryIn=1 → S = 0
# N=0, Z=1, C=1, V=0
11111111111111111111111111111111 11111111111111111111111111111111 00000 1 0110 00000000000000000000000000000000 0110

# A = 0x00000000, B = 0x00000000, CarryIn=1 → S = 0
# N=0, Z=1, C=1, V=0
00000000000000000000000000000000 00000000000000000000000000000000 00000 1 0110 00000000000000000000000000000000 0110

# A = 0xFFFFFFFF, B = 0x00000001, CarryIn=1 → S = 0x00000002
# N=0, Z=0, C=0, V=0
11111111111111111111111111111111 00000000000000000000000000000001 00000 1 0110 00000000000000000000000000000010 0000

# ------------------------------------------------------------
# ROR – Rotate Right (codop = 0111) N Z C V=0
# ------------------------------------------------------------

# B = 0x00000001, shift = 1 → S = 0x80000000, C = dernier bit sortant = 1
# Décalage 1 bit, bit LSB=1 devient MSB
00000000000000000000000000000000 00000000000000000000000000000001 00001 0 0111 10000000000000000000000000000000 1010
# N=1 (MSB=1), Z=0, C=1 (dernier bit sortant), V=0

# B = 0x80000000, shift = 1 → S = 0x40000000, C = 0
# Décalage 1 bit, bit LSB=0
00000000000000000000000000000000 10000000000000000000000000000000 00001 0 0111 01000000000000000000000000000000 0000
# N=0, Z=0, C=0, V=0

# B = 0xFFFFFFFF, shift = 4 → S = 0xFFFFFFFF, C = 1
# Tous les bits = 1, rotation multiple
00000000000000000000000000000000 11111111111111111111111111111111 00100 0 0111 11111111111111111111111111111111 1010
# N=1, Z=0, C=1, V=0

# B = 0x00000001, shift = 31 → S = 0x00000002, C = 1
# Décalage maximal, bit 0 devient avant-dernier
00000000000000000000000000000000 00000000000000000000000000000001 11111 0 0111 00000000000000000000000000000010 0000
# N=0, Z=0, C=0, V=0

# B = 0x00000000, shift = 5 → S = 0x00000000, C = 0
# Rotation d’une valeur zéro → reste zéro, test Z
00000000000000000000000000000000 00000000000000000000000000000000 00101 0 0111 00000000000000000000000000000000 0100
# N=0, Z=1, C=0, V=0

# B = 0xAAAAAAAA, shift = 4 → S = 0xAAAAAAAA, C = 0
# Mot binaire 10101010..., rotation multiple, dernier bit sortant = 0
00000000000000000000000000000000 10101010101010101010101010101010 00100 0 0111 10101010101010101010101010101010 1010
# N=1, Z=0, C=1, V=0

# ------------------------------------------------------------
# TST logique (A AND B) (codop = 1000) , seuls flags NZ mis à jour, C=0, V=0
# Résultat affiché dans S = B
# ------------------------------------------------------------

# A = 0x80000000, B = 0xFFFFFFFF → S = 0x80000000
# N=1, Z=0, C=0, V=0
10000000000000000000000000000000 11111111111111111111111111111111 00000 0 1000 11111111111111111111111111111111 1000

# A = 0x7FFFFFFF, B = 0xFFFFFFFF → S = 0x7FFFFFFF
# N=0, Z=0, C=0, V=0
01111111111111111111111111111111 11111111111111111111111111111111 00000 0 1000 11111111111111111111111111111111 0000

# A = 0xFFFFFFFF, B = 0x00000000 → S = 0x00000000
# N=0, Z=1, C=0, V=0
11111111111111111111111111111111 00000000000000000000000000000000 00000 0 1000 00000000000000000000000000000000 0100

# A = 0xAAAAAAAA, B = 0x55555555 → S = 0x00000000
# N=0, Z=1, C=0, V=0
10101010101010101010101010101010 01010101010101010101010101010101 00000 0 1000 01010101010101010101010101010101 0100

# A = 0xFFFFFFFF, B = 0xFFFFFFFF → S = 0xFFFFFFFF
# N=1, Z=0, C=0, V=0
11111111111111111111111111111111 11111111111111111111111111111111 00000 0 1000 11111111111111111111111111111111 1000

# A = 0x00000000, B = 0x00000000 → S = 0x00000000
# N=0, Z=1, C=0, V=0
00000000000000000000000000000000 00000000000000000000000000000000 00000 0 1000 00000000000000000000000000000000 0100

# ------------------------------------------------------------
# RSB (codop = 1001) N Z C=0 V
# ------------------------------------------------------------

# A = 0x00000000 (0)
# 0 - 0 = 0 → Z=1
00000000000000000000000000000000 00000000000000000000000000000000 00000 0 1001 00000000000000000000000000000000 0100
# N=0, Z=1, C=0, V=0

# A = 0x00000001 (+1)
# 0 - 1 = -1 → négatif
00000000000000000000000000000001 00000000000000000000000000000000 00000 0 1001 11111111111111111111111111111111 1000
# N=1, Z=0, C=0, V=0

# A = 0xFFFFFFFF (-1)
# 0 - (-1) = +1 → positif
11111111111111111111111111111111 00000000000000000000000000000000 00000 0 1001 00000000000000000000000000000001 0000
# N=0, Z=0, C=0, V=0

# A = 0x7FFFFFFF (+2147483647)
# 0 - max positif = négatif
01111111111111111111111111111111 00000000000000000000000000000000 00000 0 1001 10000000000000000000000000000001 1000
# N=1, Z=0, C=0, V=0

# A = 0x80000000 (-2147483648) ⚠ CAS LIMITE
# 0 - (-2147483648) = +2147483648 → overflow signé
10000000000000000000000000000000 00000000000000000000000000000000 00000 0 1001 10000000000000000000000000000000 1001
# N=1, Z=0, C=0, V=1

# ------------------------------------------------------------
# CMP (codop = 1010):  B - A (résultat non écrit, S = B)
# Drapeaux : N Z C V
# ------------------------------------------------------------

# A = 0x00000001 (+1), B = 0x00000001 (+1)
# B - A = 0 → égalité
00000000000000000000000000000001 00000000000000000000000000000001 00000 0 1010 00000000000000000000000000000001 0110
# N=0, Z=1, C=1, V=0

# A = 0x00000001 (+1), B = 0x00000000 (0)
# B - A = -1 → négatif, overflow non signé
00000000000000000000000000000001 00000000000000000000000000000000 00000 0 1010 00000000000000000000000000000000 1000
# N=1, Z=0, C=0, V=0

# A = 0xFFFFFFFF (-1), B = 0x00000000 (0)
# B - A = +1 → positif
11111111111111111111111111111111 00000000000000000000000000000000 00000 0 1010 00000000000000000000000000000000 0000
# N=0, Z=0, C=0, V=0

# A = 0x7FFFFFFF (+max), B = 0x80000000 (-min)
# B - A = (-min) - (+max) → overflow signé
01111111111111111111111111111111 10000000000000000000000000000000 00000 0 1010 10000000000000000000000000000000 0011
# N=0, Z=0, C=1, V=1

# A = 0x80000000 (-min), B = 0x7FFFFFFF (+max)
# B - A = (+max) - (-min) → overflow signé et non signé
10000000000000000000000000000000 01111111111111111111111111111111 00000 0 1010 01111111111111111111111111111111 1001
# N=1, Z=0, C=0, V=1

# A = 0x80000000 (-min), B = 0x80000000 (-min)
# B - A = 0 → égalité, pas d’overflow
10000000000000000000000000000000 10000000000000000000000000000000 00000 0 1010 10000000000000000000000000000000 0110
# N=0, Z=1, C=1, V=0

# ------------------------------------------------------------
# CMN (codop = 1011) : A + B (résultat non écrit, S = B)
# Drapeaux : NZC=0V
# ------------------------------------------------------------

# A = 0x00000001 (+1), B = 0xFFFFFFFF (-1)
# A + B = 0 → égalité, overflow non signé
00000000000000000000000000000001 11111111111111111111111111111111 00000 0 1011 11111111111111111111111111111111 0110
# N=0, Z=1, C=1, V=0

# A = 0x00000001 (+1), B = 0x00000001 (+1)
# A + B = +2 → positif
00000000000000000000000000000001 00000000000000000000000000000001 00000 0 1011 00000000000000000000000000000001 0000
# N=0, Z=0, C=0, V=0

# A = 0xFFFFFFFF (-1), B = 0xFFFFFFFF (-1)
# A + B = -2 → négatif, overflow non signé
11111111111111111111111111111111 11111111111111111111111111111111 00000 0 1011 11111111111111111111111111111111 1010
# N=1, Z=0, C=1, V=0

# A = 0x7FFFFFFF (+max), B = 0x00000001 (+1)
# A + B = +2147483648 → overflow signé
01111111111111111111111111111111 00000000000000000000000000000001 00000 0 1011 00000000000000000000000000000001 1001
# N=1, Z=0, C=0, V=1

# A = 0x80000000 (-min), B = 0xFFFFFFFF (-1)
# A + B = -2147483649 → overflow signé et non signé
10000000000000000000000000000000 11111111111111111111111111111111 00000 0 1011 11111111111111111111111111111111 0011
# N=0, Z=0, C=1, V=1

# A = 0x80000000 (-min), B = 0x80000000 (-min)
# A + B = -4294967296 → overflow signé et non signé
10000000000000000000000000000000 10000000000000000000000000000000 00000 0 1011 10000000000000000000000000000000 0111
# N=0, Z=1, C=1, V=1

# ------------------------------------------------------------
# ORR (codop = 1100) : S = A OR B
# Drapeaux : N Z C=0 V=0
# ------------------------------------------------------------

# A = 0x00000000, B = 0x00000000
# 0 OR 0 = 0
00000000000000000000000000000000 00000000000000000000000000000000 00000 0 1100 00000000000000000000000000000000 0100
# N=0, Z=1, C=0, V=0

# A = 0x00000000, B = 0x00000001
# 0 OR 1 = 1
00000000000000000000000000000000 00000000000000000000000000000001 00000 0 1100 00000000000000000000000000000001 0000
# N=0, Z=0, C=0, V=0

# A = 0x00000001, B = 0x00000001
# 1 OR 1 = 1
00000000000000000000000000000001 00000000000000000000000000000001 00000 0 1100 00000000000000000000000000000001 0000
# N=0, Z=0, C=0, V=0

# A = 0x80000000, B = 0x00000000
# bit de signe OR 0 → résultat négatif
10000000000000000000000000000000 00000000000000000000000000000000 00000 0 1100 10000000000000000000000000000000 1000
# N=1, Z=0, C=0, V=0

# A = 0x80000000, B = 0x00000001
# bit de signe forcé à 1
10000000000000000000000000000000 00000000000000000000000000000001 00000 0 1100 10000000000000000000000000000001 1000
# N=1, Z=0, C=0, V=0

# Test 6 : A = 0x7FFFFFFF, B = 0x80000000
# tous les bits à 1
01111111111111111111111111111111 10000000000000000000000000000000 00000 0 1100 11111111111111111111111111111111 1000
# N=1, Z=0, C=0, V=0


# ------------------------------------------------------------
# MUL (codop = 1101): S = A × B (32 bits LSB)
# Drapeaux : N Z C=0 V=0
# ------------------------------------------------------------

# A = 0x00000000 (0), B = 0x12345678
# 0 × X = 0
00000000000000000000000000000000 00010010001101000101011001111000 00000 0 1101 00000000000000000000000000000000 0100
# N=0, Z=1, C=0, V=0

# A = 0x00000001 (+1), B = 0x00000001 (+1)
# 1 × 1 = 1
00000000000000000000000000000001 00000000000000000000000000000001 00000 0 1101 00000000000000000000000000000001 0000
# N=0, Z=0, C=0, V=0

# A = 0xFFFFFFFF (-1), B = 0x00000001 (+1)
# -1 × 1 = -1
11111111111111111111111111111111 00000000000000000000000000000001 00000 0 1101 11111111111111111111111111111111 1000
# N=1, Z=0, C=0, V=0

# A = 0xFFFFFFFF (-1), B = 0xFFFFFFFF (-1)
# -1 × -1 = +1
11111111111111111111111111111111 11111111111111111111111111111111 00000 0 1101 00000000000000000000000000000001 0000
# N=0, Z=0, C=0, V=0

# A = 0x80000000 (-2147483648), B = 0x00000001 (+1)
# MIN_INT × 1 = MIN_INT
10000000000000000000000000000000 00000000000000000000000000000001 00000 0 1101 10000000000000000000000000000000 1000
# N=1, Z=0, C=0, V=0

# A = 0x80000000 (-2147483648), B = 0xFFFFFFFF (-1)
# MIN_INT × -1 = +2147483648 → overflow → résultat tronqué
10000000000000000000000000000000 11111111111111111111111111111111 00000 0 1101 10000000000000000000000000000000 1000
# N=1, Z=0, C=0, V=0

# ------------------------------------------------------------
# BIC (codop = 1110) : S = B AND (~A)
# Drapeaux : N Z C=0 V=0
# ------------------------------------------------------------

# A = 0x00000000, B = 0x00000000
# B AND ~A = 0 AND 1 = 0
00000000000000000000000000000000 00000000000000000000000000000000 00000 0 1110 00000000000000000000000000000000 0100
# N=0, Z=1, C=0, V=0

# A = 0x00000000, B = 0xFFFFFFFF
# B AND ~A = 1 AND 1 = B conservé
00000000000000000000000000000000 11111111111111111111111111111111 00000 0 1110 11111111111111111111111111111111 1000
# N=1, Z=0, C=0, V=0

# A = 0xFFFFFFFF, B = 0xFFFFFFFF
# B AND ~A = 1 AND 0 = 0
11111111111111111111111111111111 11111111111111111111111111111111 00000 0 1110 00000000000000000000000000000000 0100
# N=0, Z=1, C=0, V=0

# A = 0x80000000, B = 0x00000000
# bit de signe non présent → résultat 0
10000000000000000000000000000000 00000000000000000000000000000000 00000 0 1110 00000000000000000000000000000000 0100
# N=0, Z=1, C=0, V=0

# A = 0x80000000, B = 0x80000000
# ~A = 0x7FFFFFFF → B AND ~A = 0x80000000 AND 0x7FFFFFFF = 0
10000000000000000000000000000000 10000000000000000000000000000000 00000 0 1110 00000000000000000000000000000000 0100
# N=0, Z=1, C=0, V=0

# A = 0x7FFFFFFF, B = 0x80000000
# ~A = 0x80000000 → B AND ~A = 0x80000000
01111111111111111111111111111111 10000000000000000000000000000000 00000 0 1110 10000000000000000000000000000000 1000
# N=1, Z=0, C=0, V=0

# ------------------------------------------------------------
# MVN (codop = 1111) : S = ~A
# Drapeaux : N Z C=0 V=0
# ------------------------------------------------------------

# A = 0x00000000
# ~0 = 0xFFFFFFFF
00000000000000000000000000000000 00000000000000000000000000000000 00000 0 1111 11111111111111111111111111111111 1000
# N=1, Z=0, C=0, V=0

# A = 0xFFFFFFFF
# ~0xFFFFFFFF = 0x00000000
11111111111111111111111111111111 00000000000000000000000000000000 00000 0 1111 00000000000000000000000000000000 0100
# N=0, Z=1, C=0, V=0

# A = 0x80000000
# ~0x80000000 = 0x7FFFFFFF
10000000000000000000000000000000 00000000000000000000000000000000 00000 0 1111 01111111111111111111111111111111 0000
# N=0, Z=0, C=0, V=0

# A = 0x7FFFFFFF
# ~0x7FFFFFFF = 0x80000000
01111111111111111111111111111111 00000000000000000000000000000000 00000 0 1111 10000000000000000000000000000000 1000
# N=1, Z=0, C=0, V=0

# A = 0x12345678
# ~0x12345678 = 0xEDCBA987
00010010001101000101011001111000 00000000000000000000000000000000 00000 0 1111 11101101110010111010100110000111 1000
# N=1, Z=0, C=0, V=0

# A = 0xEDCBA987
# ~0xEDCBA987 = 0x12345678
11101101110010111010011010000111 00000000000000000000000000000000 00000 0 1111 00010010001101000101100101111000 0000
# N=0, Z=0, C=0, V=0


